{"version":3,"sources":["row_mouse_selection.md"],"names":[],"mappings":"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","sourcesContent":["# Mouse Row Selection\n\nMouse row selection is a feature common in most grids. We expect that when we `\"click\"` on the row or row header then the row shows as selected. In this example, the rows are grouped as well, and when\nthe group is selected then rows under the group should show as selected too. We'll also allow the user to make multiple selections when holding down the `ctrl` or `metaKey`.\n\nSounds like the bulk of the logic belongs in a `\"click\"` `EventListener`, so our `addRowMouseSelection()` should take a `table` and add a `clickListener()`.\n\nIt will also be responsible for adding the `StyleListener` to ensure the selection shows correctly as the `table` scrolls.\n\n# API\n\n```html\n<regular-table id=\"example_table\"></regular-table>\n```\n\nWe can load default selections to this example and wire up the `DataListener` borrowed from `two_billion_rows`, and then we simply `addRowMouseSelection()` to the `table` and `draw()`.\n\n```html\n<script type=\"module\">\n    import { addRowMouseSelection } from \"./row_mouse_selection.js\";\n    import { dataListener } from \"/dist/examples/two_billion_rows.js\";\n\n    window.addEventListener(\"load\", () => {\n        const dl = dataListener(200, 50);\n        example_table.setDataListener(dl);\n        addRowMouseSelection(example_table, dl, {\n            selected: [\n                {\n                    row_header: [\"Group 10\", \"Row 11\"],\n                    y0: 11,\n                    y1: 11,\n                },\n                {\n                    row_header: [\"Group 10\", \"Row 15\"],\n                    y0: 14,\n                    y1: 15,\n                },\n                {\n                    row_header: [\"Group 10\", \"Row 18\"],\n                    y0: 17,\n                    y1: 18,\n                },\n            ],\n        });\n        example_table.draw();\n    });\n</script>\n```\n\n## `addRowMouseSelection()`\n\nLets make the row selection behavior available with a single function, `addRowMouseSelection()`, that takes a `<regular-table>` and the `DataListener` then applies our behavior on `\"click\"`.\n\n```javascript\nconst PRIVATE = Symbol(\"Row Mouse Selection\");\nconst MOUSE_SELECTED_ROW_CLASS = \"mouse-selected-row\";\n\nexport const addRowMouseSelection = (table, dl, { cellSelectionEnabled = true, className = MOUSE_SELECTED_ROW_CLASS, selected = [] } = {}) => {\n    table[PRIVATE] = { selected_rows: selected };\n\n    const clickListener = (event) => {\n        const meta = table.getMeta(event.target);\n\n        const headerWasClicked = meta && typeof meta.row_header_x !== \"undefined\" && meta.row_header;\n\n        const cellWasClicked = meta && typeof meta.y !== \"undefined\" && !meta.column_header_y;\n\n        if (headerWasClicked) {\n            table[PRIVATE] = {\n                selected_rows: newRowSelections(table, meta, event, dl),\n            };\n        } else if (cellWasClicked && cellSelectionEnabled) {\n            table[PRIVATE] = {\n                selected_rows: newRowSelections(table, meta, event, dl),\n            };\n        } else if (!event.ctrlKey && !event.metaKey) {\n            table[PRIVATE] = { selected_rows: [] };\n        }\n        table.draw();\n    };\n\n    table.addEventListener(\"click\", clickListener);\n    addRowSelectionStyleListener(table, dl, className);\n    return table;\n};\n```\n\nOur internal `clickListener()` will need to keep track of the information that describes our row selection. The properties we're interested in will overlap a bit with the `MetaData` `object`, and\nwe'll refer to an `object` with the below properties as a `RowSelection`.\n\n| Name | Type | Description |\n| ---- | ---- | ----------- |\n| [y0] | `number` | The `y` index that begins the selection. |\n| [y1] | `number` | The `y` index that ends the selection. |\n| [row_header_x] | `number` | The `y` of this header's `row_header`. |\n| [row_header] | <code>Array.<object></code> | Header selections. |\n\nWe'll add them to a collection, say keyed on the `table`. In our `clickListener()`, we'll check if the `headerWasClicked` and if so, we can update the `selected_rows` with the `newRowSelections()`. If\nthe `ctrlKey` and `metaKey` aren't pressed then our user isn't multi-selecting, and we should clear the prior selections. Finally, we'll call `draw()` on the `table` ensuring the new selection shows.\n\n### When creating `newRowSelections()`\n\nIf the `metaKey` or `ctrlKey` are pressed, we'll consider the interaction to be `inMultiSelectMode` and add or remove selections - otherwise, we'll return a new selection that replaces the entire\ncollection.\n\nWe've also defined a helper function, `targetRowSelection()`, .. with the help of our `DataListener`, it takes a `MetaData` `object` and generates a `RowSelection` updating the `y0` to the `meta.y`\nand the `y1` to the `lastIndexOfRowGroup()` if this selection represents a group of rows - effectively making it a range selection. We'll save the implementation of `lastIndexOfRowGroup()` for later.\n\n```javascript\nconst newRowSelections = (table, meta, event, dl) => {\n    const inMultiSelectMode = event.ctrlKey || event.metaKey;\n    const targetSelection = targetRowSelection(meta, dl);\n\n    if (inMultiSelectMode) {\n        return newMultiSelectRow(table, targetSelection, dl);\n    } else {\n        return newSingleSelectRow(table, targetSelection, dl);\n    }\n};\n\nconst targetRowSelection = (meta, dl) => {\n    const target = { ...meta };\n    target.y0 = meta.y;\n\n    const isRowGroup = typeof meta.row_header_x !== \"undefined\" && meta.row_header_x !== meta.row_header.length - 1;\n    if (isRowGroup) {\n        target.y1 = lastIndexOfRowGroup(dl, meta);\n    } else {\n        target.y1 = meta.y;\n    }\n\n    return target;\n};\n```\n\nIn `newSingleSelectRow()`, we'll need to define three different behaviors - single selection, deselection and range selection.\n\nMost spreadsheets will allow the end user to select a range of rows, so we'll consider selections made with the `shiftKey` a range selection. Without the `shiftKey`, we'll `return` the single row\nselection or deselect it if a matching selection already exists by returning empty.\n\n```javascript\nconst newSingleSelectRow = (table, targetSelection, dl) => {\n    const matches = matchingRowSelections(table, targetSelection);\n\n    if (matches.length > 0) {\n        return [];\n    } else {\n        if (event.shiftKey) {\n            return [createRowRangeSelection(table, targetSelection, dl)];\n        } else {\n            return [targetSelection];\n        }\n    }\n};\n```\n\nWe'll need a couple helper functions, one that returns the `matchingRowSelections()` by iterating throught the `selected_rows` and returning all `RowSelection`s who's rows intersect...\n\n```javascript\nconst matchingRowSelections = (table, { y, y0, y1 }) => {\n    const _y = y !== undefined ? y : Math.min(y0, y1);\n    return table[PRIVATE].selected_rows.filter((s) => s.y0 <= _y && _y <= s.y1);\n};\n```\n\n... and a way to create a `RowSelection` that represents a range selection by looking at the `lastSelection` in `selected_rows`. If there is a `lastSelection`, we'll update the given `rowSelection`\nwith the `min()` `y0` and `max` `y1` to ensure the correct range selecting top to bottom as well as bottom to top. `createRowRangeSelection()` will also ensure that the resulting `RowSelection`\nrepresents a range over a uniform level of selections. If one of the selections is a Group and the other is a Row we should select the appropriate `row_header_x`.\n\n```javascript\nconst createRowRangeSelection = (table, rowSelection, dl) => {\n    const selectedRows = table[PRIVATE].selected_rows;\n    const lastSelection = selectedRows[selectedRows.length - 1];\n\n    if (lastSelection) {\n        const y0 = Math.min(rowSelection.y0, lastSelection.y0, rowSelection.y1, lastSelection.y1);\n        const y1 = Math.max(rowSelection.y0, lastSelection.y0, rowSelection.y1, lastSelection.y1);\n        const row_header_x = Math.min(rowSelection.row_header_x, lastSelection.row_header_x);\n        rowSelection.y0 = y0;\n        rowSelection.y1 = y1;\n    }\n    return rowSelection;\n};\n```\n\nOur multi-select implementation is slightly more complicated when we find a match. If the user clicks on an already selected row header `inMultiSelectMode` we want to simply remove the selection, but\nif the selection is a range, we'll need to split the range into two row selections, removing the `targetSelection`.\n\n```javascript\nconst newMultiSelectRow = (table, targetSelection, dl) => {\n    const matches = matchingRowSelections(table, targetSelection);\n\n    if (matches.length > 0) {\n        let newSelections = rejectMatchingRowSelections(table, targetSelection);\n        return splitRowRangeMatches(newSelections, targetSelection);\n    } else {\n        if (event.shiftKey) {\n            return table[PRIVATE].selected_rows.concat(createRowRangeSelection(table, targetSelection, dl));\n        } else {\n            return table[PRIVATE].selected_rows.concat(targetSelection);\n        }\n    }\n};\n```\n\nWe can write a complement to our `matchingRowSelections()` that returns all the `RowSelection`s that don't match the input's row.\n\n```javascript\nconst rejectMatchingRowSelections = (table, { y, y0, y1 }) => {\n    const _y = y ? y : Math.min(y0, y1);\n    return table[PRIVATE].selected_rows.filter(({ y0, y1 }) => !(y0 == _y && _y == y1));\n};\n```\n\nAnd we'll need a way to split all the matching range `RowSelection`s. This one's a bit dense, but let's walk through it. We iterate through the `selections` and find matches based on the overlap of\n`y0`s and `y1`s similar to our `matchingRowSelections()` helper. If it's a matching range (ie. the `y0` and `y1` aren't equal) then we return potentially two `RowSelections` - the part of the range up\nto the `rowSelection` passed in and the part after. Our use of `flatMap()` ensures that the result is a one-dimensional `Array` of `RowSelections`.\n\n```javascript\nconst splitRowRangeMatches = (selections, rowSelection) => {\n    return selections.flatMap((s) => {\n        const row_header_x = Math.max(rowSelection.row_header_x, s.row_header_x);\n        const matchesRangeSelection = s.y0 <= rowSelection.y0 && rowSelection.y1 <= s.y1 && s.y0 !== s.y1;\n\n        if (matchesRangeSelection) {\n            const firstSplit = {\n                row_header_x,\n                y0: s.y0,\n                y1: rowSelection.y0 - 1,\n                row_header: s.row_header,\n            };\n            const secondSplit = {\n                row_header_x,\n                y0: rowSelection.y1 + 1,\n                y1: s.y1,\n                row_header: s.row_header,\n            };\n            return [firstSplit, secondSplit].filter((s) => s.y0 <= s.y1);\n        } else {\n            return s;\n        }\n    });\n};\n```\n\n### `lastIndexOfRowGroup()`\n\nWe need a way to scan the `row_headers` present in the `DataListener` and find the end, _`y`_, of the group if a group of rows is selected. We've chosen to chunk our scan preventing a crash in the\nevent that the `DataModel` represents `two_billion_rows`.\n\n```javascript\nconst lastIndexOfRowGroup = (dl, { row_header_x, value, y }) => {\n    const { num_rows } = dl(0, 0, 1, 1);\n    let idx;\n    const chunk = 100;\n    let y0 = y;\n    let y1 = Math.min(y + chunk, num_rows);\n    do {\n        const rowHeaderSlice = dl(0, y0, 0, y1).row_headers.map((h, idx) => [y + idx, h]);\n        const result = rowHeaderSlice.find(([_, row_headers]) => row_headers[row_header_x] !== value);\n        if (result) {\n            [idx] = result;\n        } else {\n            y0 = Math.min(y0 + chunk, num_rows);\n            y1 = Math.min(y1 + chunk, num_rows);\n        }\n    } while (idx === undefined && y1 < num_rows);\n    return idx === undefined ? num_rows : idx - 1;\n};\n```\n\n## `StyleListener`\n\nAs our `<regular-table>` is re-rendered, we will want to ensure that our selection is styled correctly by reapplying our `MOUSE_SELECTED_ROW_CLASS` class to the correct `td`s and `th`s.\n\nFirst we'll `reapplyRowTHSelection()` and have that `return` the selected `y`s, then we'll use the `y`s to `reapplyRowTDSelection()`.\n\n```javascript\nconst addRowSelectionStyleListener = (table, dl, className) => {\n    table.addStyleListener(() => {\n        const ys = reapplyRowTHSelection(table, dl, className);\n\n        if (ys.length > 0) {\n            reapplyRowTDSelection(table, ys, className);\n        } else {\n            reapplyRowSelection(table, dl, className);\n        }\n    });\n};\n\nconst reapplyRowSelection = (table, dl, className) => {\n    const elements = table.querySelectorAll(\"tbody td\");\n\n    if (elements.length > 0) {\n        for (const el of elements) {\n            const meta = table.getMeta(el);\n            const matches = matchingRowSelections(table, meta);\n            if (matches.length > 0) {\n                el.classList.add(className);\n            } else {\n                el.classList.remove(className);\n            }\n        }\n    }\n};\n```\n\nIn order to reapply row selection to our `th`s, we'll need to find all of them in our `table` and iterate over the collection - adding or removing the `MOUSE_SELECTED_ROW_CLASS` based on whether or\nnot the `th` is selected.\n\nIf the `th` is part of the selection, we'll add the class to its `classlist` and `push()` its `y` into the `selectedYs` returned.\n\nOur `isRowHeaderSelected()` function needs to scan the `visibleRowHeaders` to select groups and ranges, so as an optimization, we've calculated that once to reuse for each of the `elements`. It's a\ncollection of the `row_headers` for the range of the viewport based on the first `MetaData` in the collection mapped to include an index offset by the `y0` or viewport origin.\n\n```javascript\nconst reapplyRowTHSelection = (table, dl, className) => {\n    const elements = table.querySelectorAll(\"tbody th\");\n    let selectedYs = [];\n\n    if (elements.length > 0) {\n        const meta0 = table.getMeta(elements[0]);\n        const visibleRowHeaders = dl(0, meta0.y0, 0, meta0.y1 + 1).row_headers.map((h, idx) => [meta0.y0 + idx, h]);\n        for (const el of elements) {\n            const meta = table.getMeta(el);\n\n            if (isRowHeaderSelected(table, meta, visibleRowHeaders)) {\n                selectedYs.push(meta.y);\n                el.classList.add(className);\n            } else {\n                el.classList.remove(className);\n            }\n        }\n    }\n    return selectedYs;\n};\n```\n\nThe implementation of `isRowHeaderSelected()` can be broken down into two checks.\n\nUsing our `matchingRowSelections()` helper, we find all of the `matches` and check for a direct match - when the `row_header_x` values match.\n\nIt's a bit more complex to check if the `th` is a member of a group selection. In `isGroupMatch()`, we'll make use of our `visibleRowHeaders` collection, a two-dimensional `Array` of the form\n`[index, [\"Group 0\", \"Row 0\"]]`. First we'll `filter()` the row headers to those that intersect with the `selection`'s range, then we'll extract the `row_header` that matches our `selection`'s\n`row_header_x`. The resulting `matchingGroupValues` will look something like `[\"Group 0\", \"Group 10\", ...]`. Next, we find the indexes of each value that matches our `selection` and compare.\n\n```javascript\nconst isRowHeaderSelected = (table, meta, visibleRowHeaders) => {\n    const matches = matchingRowSelections(table, meta);\n\n    const isGroupMatch = () => {\n        return table[PRIVATE].selected_rows.find((selection) => {\n            const matchingGroupValues = visibleRowHeaders.filter(([idx]) => selection.y0 <= idx && idx <= selection.y1).map(([idx, row_headers]) => idx);\n            return selection.row_header_x < meta.row_header_x && matchingGroupValues.indexOf(meta.y) !== -1;\n        });\n    };\n    const isDirectMatch = () => !!matches.find((m) => m.row_header_x === meta.row_header_x);\n\n    return isDirectMatch() || isGroupMatch();\n};\n```\n\nBy comparison, reapplying the row `td` selection is simple. We check the `MetaData` from `getMeta()` and if its `y` is in the `ys` passed in we `add()` the `MOUSE_SELECTED_ROW_CLASS`.\n\n```javascript\nconst reapplyRowTDSelection = (table, ys, className) => {\n    const elements = table.querySelectorAll(\"tbody td\");\n\n    for (const el of elements) {\n        const meta = table.getMeta(el);\n\n        if (ys.indexOf(meta.y) !== -1) {\n            el.classList.add(className);\n        } else {\n            el.classList.remove(className);\n        }\n    }\n};\n```\n\n## Styling\n\nLet's style our `mouse-selected-row` - in this example we'll use a light yellow.\n\n```css\nregular-table tbody tr td.mouse-selected-row,\nregular-table tr th.mouse-selected-row {\n    background-color: #2771a8;\n    color: white;\n}\n```\n\nAnd we can disable the default `user-select`.\n\n```css\nregular-table tbody tr th,\nregular-table tbody tr td {\n    user-select: none;\n}\n```\n\n## Appendix (Dependencies)\n\nNone of this would work without our libraries below.\n\n```html\n<script src=\"/dist/esm/regular-table.js\"></script>\n<link rel=\"stylesheet\" href=\"/dist/css/material.css\" />\n```\n\n```block\nlicense: apache-2.0\n```\n\n"]}